#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <assert.h>
#include <time.h>
#include <errno.h>

#include "directory.h"
#include "storage.h"

#define NUM_INODES
#define BLOCK_BITFIELD_LENGTH (DISK_SIZE / BLOCK_SIZE) / 8

typedef unsigned char byte;

typedef struct meta_block {
  inode root;
  byte block_status[BLOCK_COUNT / 8 + 1];
  byte inode_status[INODE_COUNT / 8 + 1];
  inode inodes[INODE_COUNT];
} meta_block;

const long startingMemoryBlock = sizeof(meta_block) / BLOCK_SIZE + 1;
meta_block meta;
char* filePath = 0;

void
check_rv(int rv) {
  assert(rv >= 0);
}

void
seek_to(int openFd, off_t addr) {
  lseek(openFd, addr, SEEK_SET);
}

ssize_t
read_fs(off_t addr, void* buf, size_t count) {
  int openFd = open(filePath, O_RDWR);
  seek_to(openFd, addr);
  ssize_t size = read(openFd, buf, count);
  close(openFd);
  return size;
}

ssize_t
write_fs(off_t addr, void* buf, size_t count) {
  int openFd = open(filePath, O_RDWR);
  seek_to(openFd, addr);
  ssize_t size = write(openFd, buf, count);
  close(openFd);
  return size;
}

void
take_block(int blockId) {
  assert(blockId >= startingMemoryBlock);
  int byteId = blockId / (sizeof(byte) * 8);
  byte bitId = blockId % (sizeof(byte) * 8);
  meta.block_status[byteId] = meta.block_status[byteId] | (1 << bitId);
  write_fs(byteId, &meta.block_status[byteId], sizeof(byte));
}

int
block_taken(int blockId) {
  int byteId = blockId / (sizeof(byte) * 8);
  byte bitId = blockId % (sizeof(byte) * 8);
  return meta.block_status[byteId] & (1 << bitId);
}

void
take_inode(int inodeId) {
  long byteId = inodeId / (sizeof(byte) * 8);
  byte bitId = inodeId % (sizeof(byte) * 8);
  meta.inode_status[byteId] = meta.inode_status[byteId] | (1 << bitId);
  write_fs(byteId, &meta.inode_status[byteId], sizeof(byte));
}

long
get_next_block() {
  long blockId = startingMemoryBlock;
  for (; blockId < BLOCK_COUNT; ++blockId) {
    if (!block_taken(blockId)) {
      take_block(blockId);
      return blockId;
    }
  }
  return -1;
}

void
initialize_inode(inode* node) {
  node->nlink = 1;
  node->uid = getuid();
  node->gid = getgid();
  node->rdev = 0;
  struct timespec now;
  clock_gettime(CLOCK_REALTIME, &now);
  memcpy(&node->atim, &now, sizeof(struct timespec));
  memcpy(&node->mtim, &now, sizeof(struct timespec));
  memcpy(&node->ctim, &now, sizeof(struct timespec));
}

void
write_block(int blockId, void* data, size_t size) {
  long blockOffset = blockId * BLOCK_SIZE;
  write_fs(blockOffset, data, size);
}

void*
read_block(int blockId) {
  long blockOffset = blockId * BLOCK_SIZE;
  void* data = malloc(BLOCK_SIZE);
  read_fs(blockOffset, data, BLOCK_SIZE);
  return data;
}

void*
read_blocks(int* blocks, int numBlocks) {
  void* data = malloc(numBlocks * BLOCK_SIZE);
  void* current = data;
  for (int i = 0; i < numBlocks; ++i) {
    void* currentData = read_block(blocks[i]);
    memcpy(current, currentData, BLOCK_SIZE);
    free(currentData);
    current += BLOCK_SIZE;
  }
  return data;
}

long
write_data_fs(int* blockIds, void* data, size_t size) {
  long writtenSize = 0;
  int blockIndex = 0;
  while(writtenSize < size) {
    blockIds[blockIndex] = get_next_block();
    void* blockData = malloc(BLOCK_SIZE);
    long writeSize = (writtenSize + BLOCK_SIZE < size) ? BLOCK_SIZE : size - writtenSize;
    write_block(blockIds[blockIndex], data + writtenSize, writeSize);
    writtenSize += BLOCK_SIZE;
    free(blockData);
  }
  return size;
}

void
free_block(int blockId) {
  // Don't worry about 0-ing it, just mark it as free
  long byteId = blockId / (sizeof(byte) * 8);
  byte bitId = blockId % (sizeof(byte) * 8);
  // TODO make this not a magic number
  meta.inode_status[byteId] = meta.inode_status[byteId] & (255 - (1 << bitId));
  write_fs(byteId, &meta.inode_status[byteId], sizeof(byte));
}

void
free_blocks(int* blockIds, size_t count) {
  for (long i = 0; i < count; ++i) {
    free_block(blockIds[i]);
  }
}

void
release_inode_memory(inode* node) {
  if (node->usedBlocks > STARTING_BLOCKS) {
    int* blockMemory = read_block(node->moreBlocksBlock);
    free_blocks(blockMemory, node->usedBlocks);
    free(blockMemory);
  }
  else {
    free_blocks(node->blocks, node->usedBlocks);
  }
}

void
write_data_inode(inode* node, void* data, size_t size) {
  if ((node->size <= BIG_SIZE && size > BIG_SIZE) || (node->size > BIG_SIZE && size <= BIG_SIZE)) {
    release_inode_memory(node);
  }
  node->size = size;
  node->usedBlocks = size / BLOCK_SIZE + 1;
  if (node->size <= BIG_SIZE) {
    write_data_fs(node->blocks, data, size);
    write_fs((void*) node->blocks - (void*) &meta, &node->blocks, STARTING_BLOCKS * sizeof(int));
  }
  else {
    node->moreBlocksBlock = get_next_block();
    int* blockData = malloc(BLOCK_SIZE);
    write_data_fs(blockData, data, size);
    write_block(node->moreBlocksBlock, blockData, BLOCK_SIZE);
    free(blockData);
  }
}

void
write_dir_to_inode(directory* dir, inode* node) {
  size_t size = get_size_directory(dir);
  void* serialData = serialize(dir);
  write_data_inode(node, serialData, size);
}

const char*
read_inode(inode* node) {
  if (node->usedBlocks > STARTING_BLOCKS) {
    int* blocks = read_block(node->moreBlocksBlock);
    void* out = read_blocks(blocks, node->usedBlocks);
    free(blocks);
    return out;
  }
  else {
    return read_blocks(node->blocks, node->usedBlocks);
  }
}

void
configure_meta() {
  memset(&meta, 0, sizeof(meta_block));
  initialize_inode(&meta.root);
  meta.root.mode = S_IFDIR | S_IRWXU | S_IRWXG;
  directory* dir = create_directory("", 0, 0);
  meta.root.size = get_size_directory(dir);
  write_dir_to_inode(dir, &meta.root);
}

void
storage_init(const char* path) {
  int openFd = open(path, O_CREAT | O_TRUNC | O_RDWR);
  check_rv(openFd);
  int rv = ftruncate(openFd, DISK_SIZE);
  check_rv(rv);
  close(openFd);

  filePath = (char*) path;
  read_fs(0, &meta, sizeof(meta_block));
  if (meta.root.nlink == 0) {
    configure_meta();
    write_fs(0, &meta, sizeof(meta_block));
  }
}

long
get_stat(const char* path, struct stat* st)
{
  inode* node = get_inode(path);
  return get_stat_inode(node, st);
}

long
get_stat_inode_id(long inodeId, struct stat* st) {
  return get_stat_inode(&meta.inodes[inodeId], st);
}

long
get_stat_inode(inode* node, struct stat* st) {
  if ((long) node <= 0) {
    return (long) node;
  }
  st->st_dev = 0;
  st->st_ino = ((long)((void*)node - (void*)meta.inodes)) / sizeof(inode);
  st->st_mode = node->mode;
  st->st_nlink = node->nlink;
  st->st_gid = node->gid;
  st->st_uid = node->uid;
  st->st_rdev = node->rdev;
  st->st_size = node->size;
  st->st_blksize = (node->size / BLOCK_SIZE ) + 1;
  st->st_blocks = (node->size / BLOCK_SIZE) + 1;
  memcpy(&st->st_atim, &node->atim, sizeof(struct timespec));
  memcpy(&st->st_mtim, &node->mtim, sizeof(struct timespec));
  memcpy(&st->st_ctim, &node->ctim, sizeof(struct timespec));

  return 0;
}

const char*
get_data(const char* path) {
  inode* node = get_inode(path);
  return read_inode(node);
}

inode*
get_inode(const char* path) {
  inode* currentNode = &meta.root;
  // This should just happen once
  while (*path && *path == '/') {
    ++path;
  }
  char* nameStart = (char*) path;
  while (*nameStart && is_directory(currentNode)) {
    int nameLen = 0;
    while (path[nameLen] && path[nameLen] != '/') {
      ++nameLen;
    }
    char* fileName = malloc(sizeof(char) * (nameLen + 1));
    strncpy(fileName, path, nameLen);
    fileName[nameLen] = 0;
    directory* dir = read_directory(currentNode);
    long nextInode = get_file_inode(dir, fileName);
    if (nextInode < 0) {
      return (inode*) -ENOENT;
    }
    currentNode = &meta.inodes[nextInode];
    free(fileName);
    nameStart += nameLen + 1;
  }
  return currentNode;
}

void
get_dirent(const char* path, struct dirent* dirInfo) {
  inode* node = get_inode(path);
  dirInfo->d_ino = ((long)(node - &meta.inodes[0])) / sizeof(inode);
  dirInfo->d_off = 0;
  dirInfo->d_reclen = node->size;
  dirInfo->d_type = (is_directory(node)) ? DT_DIR : node->mode;
  char name[256] = "";
  memcpy(&dirInfo->d_name, &name, 256);
}

directory*
read_directory(inode* node) {
  void* data = (void*) read_inode(node);
  directory* dir = deserialize(data, node->size);
  free(data);
  return dir;
}

int
is_directory(inode* node) {
  return node->mode & S_IFDIR;
}
